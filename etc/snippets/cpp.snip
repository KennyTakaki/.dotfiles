snippet     headerlib
abbr        * @file .h
options     head
    /** 
     * @file `expand("%:r")`.h
     * @brief 
     * @author Kentarou Takaki
     */
    #pragma once
     
    /** 
     * @brief 
     */
    class `expand("%:r")`{
      public:
        `expand("%:r")`(){}
     
        //~~~~~~functions~~~~~~~
     
      private:
     
        //~~~~~~Struct/Enum~~~~~~
     
        //~~~~~~Members~~~~~
     
        //~~~~~~functions~~~~~~~
     
    };

snippet     tk_class_h
abbr        tkabbr
options     head
  /**
  * @file      ${1:`expand("%:r")`}.h
  * @brief     クラスの説明
  * @note      特記事項など
  * @author    Kentarou Takaki @ SEI
  * @copyright ~~~~~~~
  */
  ${0}
  // include guard should be the form of <PROJECT>_<PATH>_<FILE>_H_
  #ifndef ${2:ORGANIZATION_PROJECT_PACKAGE_LIB_CLASSNAME_H___}
  #define $2
  
  //-------------------------------------------------------
  // includes
  //-------------------------------------------------------
  ${3:#include <iostream>}
  //-------------------------------------------------------
  // defines
  //-------------------------------------------------------
  //using new_type = oiginal_type

  //-------------------------------------------------------
  // namespace
  //-------------------------------------------------------
  
  namespace ${4:organization} {
  namespace ${5:project} {
  namespace ${6:package} {
  
  //-------------------------------------------------------
  // public classes
  //-------------------------------------------------------
  // 公開クラスの定義はここに記述します
  
  /**
   * 基底クラスの最低限の定義
   */
  class $1
  {
    public:
      /**
       * デフォルトコンストラクタ
       */
      $1() {}
  
      /**
       * 引数ありコンストラクタ
       * @param value
       */
      explicit $1(${7:const\ std::string\ &value})
          : privateMember_(value) {}
  
      /**
       * コピーコンストラクタ
       * コピーを抑止したい場合は = deleteと指定します
       *
       * @param from   コピー元インスタンス
       */
      $1(const $1 &from)
          : privateMember_(from.privateMember_) {}
  
      /**
       * コピー代入演算子のオーバーロード
       * 代入を抑止したい場合は = deleteと指定します
       *
       * @param from   代入元インスタンス
       */
      $1 &operator=(const $1 &from);
  
      /**
       * ムーブコンストラクタ
       * 必要に応じて宣言します
       */
      $1($1 &&rhs) noexcept = delete;
  
      /**
       * ムーブ代入演算子
       * 必要に応じて宣言します
       */
      $1 &operator=($1 &&rhs) noexcept = delete;
  
      /**
       * デストラクタ
       * 基底クラスは必ずvirtualを付けます
       */
      virtual ~$1() {}
  
      /**
       * 公開関数
       * 形式を極力統一するため、戻り値ではエラー情報を返し、
       * 演算結果は引数に渡された出力用変数に代入するように定義します
       *
       * @param input  入力パラメータ
       * @param output 出力を返す領域
       * @retval エラー状態
       */
      Error publicMethod(const std::string &input, std::string &output) noexcept;
  
      /**
       * getter系関数のように、実行しても
       * メンバ変数の状態を変更しない関数はconstを付けます
       * このような関数はスレッドセーフになるように設計します
       */
      virtual std::string toString() const;
  
      /**
       * 純粋仮想関数
       * Abstract Classとする場合にインターフェースとなる関数を定義します
       */
      // virtual void abstractMethod() = 0;
  
      //------------------------------------------
      // クラス定数
      //------------------------------------------
      //static constexpr uint32_t const CONST_INTEGER = 0; ///< コンパイル時定数とすることで配列の添え字に利用できます
      //static constexpr char *const CONST_STRING = (char *const) "compile-time constants"; ///< 文字列リテラルも定義可能です
  
  
    private:
      /**
       * private変数
       */
      std::string privateMember_;
  
      // const関数をスレッドセーフにするためのMutexオブジェクトを使う場合は
      // const関数内で変更できるようにMutexオブジェクトに「mutable」を指定します
      // mutable std::mutex mutexToString_;
  };
  
  
  } // namespace $6
  } // namespace $5
  } // namespace $4
  #endif // include guard
